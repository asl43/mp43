<!doctype html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Extrator e Conversor de √Åudio/V√≠deo</title>
    <style>
        :root {
            --primary: #007bff;
            --primary-dark: #0056b3;
            --success: #28a745;
            --success-dark: #1e7e34;
            --warning: #ffc107;
            --warning-dark: #d39e00;
            --danger: #dc3545;
            --danger-dark: #c82333;
            --info: #17a2b8;
            --info-dark: #117a8b;
            --bg-light: #f8f9fa;
            --bg-dark: #343a40;
            --text-dark: #212529;
            --text-light: #f8f9fa;
            --border-color: #dee2e6;
            --card-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.05);
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-light);
            color: var(--text-dark);
            margin: 0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            background: #fff;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            padding: 30px;
            border: 1px solid var(--border-color);
        }

        h1 {
            font-size: 2rem;
            margin: 0 0 8px;
            font-weight: 700;
            color: var(--text-dark);
        }

        h2, h3, h4 {
            margin: 20px 0 10px;
            font-weight: 600;
        }

        p.lead {
            color: #6c757d;
            margin: 0 0 20px;
            font-size: 1.1rem;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 0.95rem;
        }

        .alert-warning {
            background-color: #fff3cd;
            border-left: 4px solid var(--warning);
            color: #856404;
        }

        .alert-info {
            background-color: #d1ecf1;
            border-left: 4px solid var(--info);
            color: #0c5460;
        }

        .alert-success {
            background-color: #d4edda;
            border-left: 4px solid var(--success);
            color: #155724;
        }

        .row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        @media (max-width: 768px) {
            .row {
                flex-direction: column;
            }
        }
        
        .col {
            flex: 1;
            min-width: 280px;
        }

        label {
            display: block;
            font-size: 0.9rem;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
        }

        .drop-area {
            border: 2px dashed var(--border-color);
            padding: 40px 20px;
            text-align: center;
            font-size: 1rem;
            color: #6c757d;
            margin-bottom: 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }

        .drop-area:hover, .drop-area.highlight {
            border-color: var(--primary);
            background-color: #e9f5ff;
            color: var(--primary-dark);
        }
        
        input[type=file] {
            display: none;
        }

        .form-control {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 0.9rem;
            background-color: #fff;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }
        
        .form-control:focus {
            outline: none;
            border-color: var(--primary);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            border: none;
            transition: all 0.2s ease-in-out;
            margin: 5px;
        }

        .btn-primary {
            background-color: var(--primary);
            color: #fff;
        }
        .btn-primary:hover { background-color: var(--primary-dark); }
        
        .btn-secondary {
            background: transparent;
            color: var(--primary);
            border: 1px solid var(--primary);
        }
        .btn-secondary:hover { background-color: var(--primary-dark); color: #fff; }

        .btn-success {
            background-color: var(--success);
            color: #fff;
        }
        .btn-success:hover { background-color: var(--success-dark); }

        .btn-danger {
            background-color: var(--danger);
            color: #fff;
        }
        .btn-danger:hover { background-color: var(--danger-dark); }
        
        .btn-disabled, .btn:disabled {
            background-color: #adb5bd;
            cursor: not-allowed;
            color: #fff;
        }

        .btn-small {
            padding: 8px 12px;
            font-size: 0.8rem;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .log {
            height: 200px;
            overflow: auto;
            margin-top: 15px;
            background: #212529;
            color: #d1fae5;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .log .error { color: #dc3545; }
        .log .success { color: #28a745; }
        .log .warning { color: #ffc107; }
        .log .info { color: #17a2b8; }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: var(--border-color);
            border-radius: 5px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--success);
            transition: width 0.3s ease-in-out;
        }
        
        .file-list {
            margin-top: 20px;
        }

        .file-item {
            padding: 15px;
            border-radius: 8px;
            background: #fff;
            margin-bottom: 12px;
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-preview {
            max-width: 100px;
            max-height: 60px;
            object-fit: cover;
            border-radius: 4px;
            margin-right: 15px;
        }

        .file-meta {
            flex-grow: 1;
        }

        .file-meta strong {
            display: block;
            margin-bottom: 5px;
        }

        .file-meta small {
            color: #6c757d;
            font-size: 0.8rem;
            display: block;
            margin-bottom: 2px;
        }

        .file-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .converted-files {
            margin-top: 30px;
        }

        .converted-item {
            padding: 15px;
            background-color: #e2f9e4;
            border: 1px solid #c8e6c9;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .converted-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .converted-name {
            font-weight: 600;
            color: var(--success-dark);
        }

        .converted-size {
            font-size: 0.8rem;
            color: var(--success-dark);
        }

        .converted-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .method-selector {
            background-color: #e9f5ff;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid var(--primary);
        }

        .method-option {
            margin: 15px 0;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }

        .method-option.selected {
            border-color: var(--primary);
            background-color: #fff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .method-option h4 {
            margin: 0 0 5px;
            color: var(--primary-dark);
            font-weight: 600;
        }

        .method-option p {
            margin: 0;
            font-size: 0.85rem;
            color: #6c757d;
        }

        .advanced-options {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid var(--border-color);
        }

        .format-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .format-option {
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .format-option:hover {
            border-color: var(--primary);
        }

        .format-option.selected {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        footer {
            margin-top: 25px;
            font-size: 0.8rem;
            color: #6c757d;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Extrator e Conversor de √Åudio/V√≠deo</h1>
        <p class="lead">Extraia √°udio de v√≠deos, converta formatos e processe arquivos de m√≠dia.</p>

        <div id="browserCompatibility"></div>

        <div class="row">
            <div class="col">
                <label>üìπ Selecionar arquivos</label>
                <div class="drop-area" id="dropArea">
                    Arraste e solte arquivos aqui, ou clique para selecionar.
                    <br><small>Suporta m√∫ltiplos arquivos</small>
                </div>
                <input id="fileInput" type="file" accept="video/*,audio/*" multiple />

                <div class="method-selector">
                    <h3>üîß Modo de Convers√£o:</h3>
                    <div class="method-option selected" data-mode="extract-audio">
                        <h4>üóÇÔ∏è Extrair √Åudio</h4>
                        <p>Extrai o √°udio de arquivos de v√≠deo usando APIs nativas do navegador.</p>
                    </div>
                    
                    <div class="method-option" data-mode="convert-format">
                        <h4>üîÑ Converter Formato</h4>
                        <p>Converte entre diferentes formatos de √°udio.</p>
                    </div>

                    <div class="method-option" data-mode="edit-audio">
                        <h4>‚úÇÔ∏è Editar √Åudio</h4>
                        <p>Cortar, ajustar volume e aplicar efeitos b√°sicos.</p>
                    </div>
                </div>

                <div class="advanced-options" id="advancedOptions">
                    <h4>‚öôÔ∏è Op√ß√µes Avan√ßadas</h4>
                    
                    <div class="form-group" id="outputFormatGroup">
                        <label>Formato de Sa√≠da:</label>
                        <div class="format-grid" id="formatGrid"></div>
                    </div>

                    <div class="form-group" id="qualityGroup">
                        <label>Qualidade:</label>
                        <select class="form-control" id="qualitySelect">
                            <option value="low">Baixa (128 kbps)</option>
                            <option value="medium" selected>M√©dia (256 kbps)</option>
                            <option value="high">Alta (320 kbps)</option>
                        </select>
                    </div>

                    <div class="form-group" id="editingGroup" style="display:none;">
                        <label>Tempo de In√≠cio (segundos):</label>
                        <input type="number" class="form-control" id="startTime" min="0" step="0.1" value="0">
                        
                        <label>Dura√ß√£o (segundos, 0 = at√© o final):</label>
                        <input type="number" class="form-control" id="duration" min="0" step="0.1" value="0">
                        
                        <label>Volume (%):</label>
                        <input type="range" class="form-control" id="volumeSlider" min="0" max="200" value="100">
                        <span id="volumeValue">100%</span>
                    </div>
                </div>

                <div class="file-list" id="fileList"></div>

                <div class="controls">
                    <button id="processBtn" class="btn btn-primary">Processar Arquivos</button>
                    <button id="clearBtn" class="btn btn-danger">üóëÔ∏è Limpar</button>
                </div>
            </div>

            <div class="col">
                <label>üìä Status e Logs</label>
                <div class="log" id="log"></div>

                <div style="margin-top:20px">
                    <label>‚öôÔ∏è Progresso</label>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width:0%"></div>
                    </div>
                    <div id="progressText" style="font-size:0.85rem;color:#6c757d">Aguardando...</div>
                </div>
            </div>
        </div>

        <div class="converted-files" id="convertedFiles" style="display:none">
            <h3>üéâ Arquivos Processados</h3>
            <div id="convertedList"></div>
        </div>

        <!-- Elementos ocultos para processamento -->
        <video id="videoElement" style="display:none" crossorigin="anonymous"></video>
        <audio id="audioElement" style="display:none" crossorigin="anonymous"></audio>
        <canvas id="canvas" style="display:none"></canvas>

        <footer>
            <strong>üîß Modo:</strong> <span id="currentMode">Extrair √Åudio</span><br>
            <strong>‚ö° Status:</strong> <span id="browserStatus">Carregando...</span>
        </footer>
    </div>

    <script>
        // Estado da aplica√ß√£o
        let selectedFiles = [];
        let convertedFiles = [];
        let isProcessing = false;
        let conversionMode = 'extract-audio';

        // Elementos DOM
        const elements = {
            fileInput: document.getElementById('fileInput'),
            fileList: document.getElementById('fileList'),
            processBtn: document.getElementById('processBtn'),
            clearBtn: document.getElementById('clearBtn'),
            log: document.getElementById('log'),
            progressFill: document.getElementById('progressFill'),
            progressText: document.getElementById('progressText'),
            convertedFiles: document.getElementById('convertedFiles'),
            convertedList: document.getElementById('convertedList'),
            currentMode: document.getElementById('currentMode'),
            browserStatus: document.getElementById('browserStatus'),
            dropArea: document.getElementById('dropArea'),
            advancedOptions: document.getElementById('advancedOptions'),
            formatGrid: document.getElementById('formatGrid'),
            qualitySelect: document.getElementById('qualitySelect'),
            startTime: document.getElementById('startTime'),
            duration: document.getElementById('duration'),
            volumeSlider: document.getElementById('volumeSlider'),
            volumeValue: document.getElementById('volumeValue'),
            videoElement: document.getElementById('videoElement'),
            audioElement: document.getElementById('audioElement'),
            canvas: document.getElementById('canvas'),
            browserCompatibility: document.getElementById('browserCompatibility'),
            editingGroup: document.getElementById('editingGroup')
        };

        const supportedFormats = {
            audio: ['mp3', 'wav', 'ogg', 'webm', 'aac'],
            video: ['mp4', 'webm', 'avi', 'mov']
        };

        // Fun√ß√£o de logging
        function log(msg, type = 'info') {
            const time = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.className = type;
            div.innerHTML = `<span style="opacity:0.7">[${time}]</span> ${msg}`;
            elements.log.appendChild(div);
            elements.log.scrollTop = elements.log.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${msg}`);
        }

        // Fun√ß√£o de progresso
        function setProgress(percent, text) {
            elements.progressFill.style.width = `${Math.min(100, Math.max(0, percent))}%`;
            elements.progressText.textContent = text;
        }

        // Verifica√ß√£o de compatibilidade
        function checkBrowserCompatibility() {
            const features = {
                mediaRecorder: !!window.MediaRecorder,
                webAudio: !!(window.AudioContext || window.webkitAudioContext),
                canvas: !!document.createElement('canvas').getContext,
                videoElement: !!document.createElement('video')
            };

            let compatibilityHTML = '';
            const supportedCount = Object.values(features).filter(Boolean).length;
            const totalCount = Object.keys(features).length;

            if (supportedCount === totalCount) {
                compatibilityHTML = '<div class="alert alert-success">‚úÖ <strong>Perfeito!</strong> Seu navegador suporta todas as funcionalidades.</div>';
            } else if (supportedCount >= totalCount - 1) {
                compatibilityHTML = '<div class="alert alert-info">‚ÑπÔ∏è <strong>Bom!</strong> A maioria das funcionalidades est√° dispon√≠vel.</div>';
            } else {
                compatibilityHTML = '<div class="alert alert-warning">‚ö†Ô∏è <strong>Limitado:</strong> Algumas funcionalidades podem n√£o funcionar.</div>';
            }

            elements.browserCompatibility.innerHTML = compatibilityHTML;
            elements.browserStatus.textContent = `${supportedCount}/${totalCount} funcionalidades suportadas`;

            return features;
        }

        // Valida√ß√£o de arquivo
        function validateFile(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            const isVideo = file.type.startsWith('video/');
            const isAudio = file.type.startsWith('audio/');
            
            return {
                valid: isVideo || isAudio,
                type: isVideo ? 'video' : (isAudio ? 'audio' : 'unknown'),
                extension: ext,
                size: file.size,
                sizeFormatted: (file.size / 1024 / 1024).toFixed(2) + ' MB'
            };
        }

        // IMPLEMENTA√á√ÉO CORRIGIDA - Extra√ß√£o de √°udio usando APIs nativas
        async function extractAudioFromVideo(file) {
            return new Promise((resolve, reject) => {
                log(`Extraindo √°udio de ${file.name}...`, 'info');
                
                const video = elements.videoElement;
                const canvas = elements.canvas;
                const ctx = canvas.getContext('2d');
                
                // Criar URL do objeto
                const url = URL.createObjectURL(file);
                video.src = url;
                
                video.onloadedmetadata = () => {
                    log(`Dura√ß√£o do v√≠deo: ${video.duration.toFixed(1)}s`, 'info');
                    
                    // Configurar canvas
                    canvas.width = 1;
                    canvas.height = 1;
                    
                    // Criar MediaStream a partir do v√≠deo
                    const stream = canvas.captureStream(30);
                    
                    // Criar contexto de √°udio
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaElementSource(video);
                    const destination = audioContext.createMediaStreamDestination();
                    source.connect(destination);
                    
                    // Configurar MediaRecorder para capturar apenas √°udio
                    const options = {
                        mimeType: 'audio/webm;codecs=opus'
                    };
                    
                    // Fallback para outros formatos se webm n√£o for suportado
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        if (MediaRecorder.isTypeSupported('audio/webm')) {
                            options.mimeType = 'audio/webm';
                        } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
                            options.mimeType = 'audio/mp4';
                        } else {
                            options.mimeType = 'audio/wav';
                        }
                    }
                    
                    const recorder = new MediaRecorder(destination.stream, options);
                    const chunks = [];
                    
                    recorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            chunks.push(event.data);
                        }
                    };
                    
                    recorder.onstop = () => {
                        const audioBlob = new Blob(chunks, { type: options.mimeType });
                        const outputName = file.name.replace(/\.[^/.]+$/, '') + '_audio.webm';
                        
                        URL.revokeObjectURL(url);
                        
                        resolve({
                            name: outputName,
                            blob: audioBlob,
                            type: audioBlob.type,
                            size: audioBlob.size,
                            originalFile: file.name
                        });
                    };
                    
                    recorder.onerror = (error) => {
                        log(`Erro no MediaRecorder: ${error.error}`, 'error');
                        URL.revokeObjectURL(url);
                        reject(error.error);
                    };
                    
                    // Come√ßar grava√ß√£o e reprodu√ß√£o
                    recorder.start();
                    video.play().then(() => {
                        log('Reproduzindo v√≠deo para extrair √°udio...', 'info');
                    }).catch(err => {
                        log(`Erro ao reproduzir v√≠deo: ${err.message}`, 'error');
                        reject(err);
                    });
                    
                    // Parar grava√ß√£o quando o v√≠deo terminar
                    video.onended = () => {
                        recorder.stop();
                        log('Extra√ß√£o de √°udio conclu√≠da!', 'success');
                    };
                };
                
                video.onerror = (error) => {
                    log(`Erro ao carregar v√≠deo: ${error.message}`, 'error');
                    URL.revokeObjectURL(url);
                    reject(error);
                };
            });
        }

        // Convers√£o de formato de √°udio
        async function convertAudioFormat(file, targetFormat) {
            return new Promise((resolve, reject) => {
                log(`Convertendo ${file.name} para ${targetFormat}...`, 'info');
                
                const audio = elements.audioElement;
                const url = URL.createObjectURL(file);
                audio.src = url;
                
                audio.onloadedmetadata = () => {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaElementSource(audio);
                    const destination = audioContext.createMediaStreamDestination();
                    source.connect(destination);
                    
                    let mimeType;
                    switch (targetFormat) {
                        case 'webm':
                            mimeType = 'audio/webm;codecs=opus';
                            break;
                        case 'mp4':
                            mimeType = 'audio/mp4';
                            break;
                        case 'ogg':
                            mimeType = 'audio/ogg;codecs=opus';
                            break;
                        default:
                            mimeType = 'audio/webm';
                    }
                    
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/webm';
                    }
                    
                    const recorder = new MediaRecorder(destination.stream, { mimeType });
                    const chunks = [];
                    
                    recorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            chunks.push(event.data);
                        }
                    };
                    
                    recorder.onstop = () => {
                        const convertedBlob = new Blob(chunks, { type: mimeType });
                        const outputName = file.name.replace(/\.[^/.]+$/, '') + '_convertido.' + targetFormat;
                        
                        URL.revokeObjectURL(url);
                        
                        resolve({
                            name: outputName,
                            blob: convertedBlob,
                            type: convertedBlob.type,
                            size: convertedBlob.size,
                            originalFile: file.name
                        });
                    };
                    
                    recorder.onerror = (error) => {
                        URL.revokeObjectURL(url);
                        reject(error.error);
                    };
                    
                    recorder.start();
                    audio.play();
                    
                    audio.onended = () => {
                        recorder.stop();
                        log('Convers√£o de formato conclu√≠da!', 'success');
                    };
                };
                
                audio.onerror = (error) => {
                    URL.revokeObjectURL(url);
                    reject(error);
                };
            });
        }

        // Edi√ß√£o de √°udio b√°sica
        async function editAudio(file, options = {}) {
            const startTime = parseFloat(options.startTime) || 0;
            const duration = parseFloat(options.duration) || 0;
            const volume = parseFloat(options.volume) || 100;
            
            log(`Editando ${file.name}...`, 'info');
            
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await audioContext.decodeAudioData(await file.arrayBuffer());
                
                const sampleRate = audioBuffer.sampleRate;
                const numChannels = audioBuffer.numberOfChannels;
                
                const startSample = Math.floor(startTime * sampleRate);
                const endSample = duration > 0 ? 
                    Math.floor((startTime + duration) * sampleRate) : 
                    audioBuffer.length;
                
                const outputLength = endSample - startSample;
                const outputBuffer = audioContext.createBuffer(numChannels, outputLength, sampleRate);
                
                // Processar cada canal
                for (let channel = 0; channel < numChannels; channel++) {
                    const inputData = audioBuffer.getChannelData(channel);
                    const outputData = outputBuffer.getChannelData(channel);
                    
                    for (let i = 0; i < outputLength; i++) {
                        let sample = inputData[startSample + i] || 0;
                        sample *= (volume / 100);
                        
                        // Aplicar fade in/out
                        const fadeDuration = Math.min(0.1 * sampleRate, outputLength / 4);
                        if (i < fadeDuration) {
                            sample *= (i / fadeDuration);
                        }
                        if (i > outputLength - fadeDuration) {
                            sample *= ((outputLength - i) / fadeDuration);
                        }
                        
                        outputData[i] = Math.max(-1, Math.min(1, sample));
                    }
                }
                
                // Converter para WAV
                const wavData = audioBufferToWav(outputBuffer);
                const outputBlob = new Blob([wavData], { type: 'audio/wav' });
                const outputName = file.name.replace(/\.[^/.]+$/, '') + '_editado.wav';
                
                return {
                    name: outputName,
                    blob: outputBlob,
                    type: 'audio/wav',
                    size: outputBlob.size,
                    originalFile: file.name
                };
                
            } catch (error) {
                log(`Erro na edi√ß√£o: ${error.message}`, 'error');
                throw error;
            }
        }

        // Fun√ß√£o para converter AudioBuffer para WAV
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;
            const dataLength = buffer.length * numChannels * (bitDepth / 8);
            
            const bufferArray = new ArrayBuffer(44 + dataLength);
            const view = new DataView(bufferArray);

            // WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * (bitDepth / 8), true);
            view.setUint16(32, numChannels * (bitDepth / 8), true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);

            // PCM audio data
            let offset = 44;
            const samples = new Int16Array(buffer.length * numChannels);
            let sampleIndex = 0;
            for (let i = 0; i < buffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    let sample = buffer.getChannelData(channel)[i];
                    sample = Math.max(-1, Math.min(1, sample));
                    samples[sampleIndex++] = sample * 0x7FFF;
                }
            }
            
            for(let i = 0; i < samples.length; i++) {
                view.setInt16(offset, samples[i], true);
                offset += 2;
            }

            return bufferArray;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Processamento principal
        async function processFiles() {
            if (selectedFiles.length === 0) {
                log('Nenhum arquivo selecionado.', 'warning');
                return;
            }

            if (isProcessing) {
                log('Processamento j√° em andamento.', 'warning');
                return;
            }

            isProcessing = true;
            elements.processBtn.disabled = true;
            
            try {
                log(`Iniciando processamento de ${selectedFiles.length} arquivo(s)...`, 'info');
                
                for (let i = 0; i < selectedFiles.length; i++) {
                    const file = selectedFiles[i];
                    const progress = (i / selectedFiles.length) * 100;
                    setProgress(progress, `Processando ${file.name}...`);
                    
                    try {
                        let result;
                        const selectedFormat = document.querySelector('.format-option.selected')?.dataset.format;
                        
                        switch (conversionMode) {
                            case 'extract-audio':
                                if (file.type.startsWith('video/')) {
                                    result = await extractAudioFromVideo(file);
                                } else {
                                    log(`${file.name} n√£o √© um arquivo de v√≠deo. Pulando...`, 'warning');
                                    continue;
                                }
                                break;
                                
                            case 'convert-format':
                                if (file.type.startsWith('audio/')) {
                                    result = await convertAudioFormat(file, selectedFormat || 'webm');
                                } else {
                                    log(`${file.name} n√£o √© um arquivo de √°udio. Pulando...`, 'warning');
                                    continue;
                                }
                                break;
                                
                            case 'edit-audio':
                                if (file.type.startsWith('audio/')) {
                                    const options = {
                                        startTime: elements.startTime.value,
                                        duration: elements.duration.value,
                                        volume: elements.volumeSlider.value
                                    };
                                    result = await editAudio(file, options);
                                } else {
                                    log(`${file.name} n√£o √© um arquivo de √°udio. Pulando...`, 'warning');
                                    continue;
                                }
                                break;
                                
                            default:
                                log(`Modo ${conversionMode} n√£o implementado.`, 'error');
                                continue;
                        }
                        
                        if (result) {
                            convertedFiles.push({
                                ...result,
                                id: `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                                url: URL.createObjectURL(result.blob)
                            });
                            log(`‚úÖ ${result.name} processado com sucesso!`, 'success');
                        }
                        
                    } catch (error) {
                        log(`‚ùå Erro ao processar ${file.name}: ${error.message}`, 'error');
                    }
                }
                
                setProgress(100, 'Processamento conclu√≠do!');
                log('Todos os arquivos foram processados!', 'success');
                
            } catch (error) {
                log(`Erro geral no processamento: ${error.message}`, 'error');
                setProgress(0, 'Erro no processamento');
            } finally {
                isProcessing = false;
                elements.processBtn.disabled = false;
                renderConvertedFiles();
            }
        }

        // Fun√ß√µes de renderiza√ß√£o
        function renderFileList() {
            elements.fileList.innerHTML = '';
            selectedFiles.forEach((file, index) => {
                const info = validateFile(file);
                const div = document.createElement('div');
                div.className = 'file-item';
                div.innerHTML = `
                    <div class="file-meta">
                        <strong>${file.name}</strong>
                        <small>Tipo: ${info.type}</small>
                        <small>Tamanho: ${info.sizeFormatted}</small>
                    </div>
                    <div class="file-actions">
                        <button class="btn btn-danger btn-small" onclick="removeFile(${index})">Remover</button>
                    </div>
                `;
                elements.fileList.appendChild(div);
            });
        }

        function renderConvertedFiles() {
            if (convertedFiles.length === 0) {
                elements.convertedFiles.style.display = 'none';
                return;
            }
            
            elements.convertedFiles.style.display = 'block';
            elements.convertedList.innerHTML = convertedFiles.map(item => `
                <div class="converted-item" data-id="${item.id}">
                    <div class="converted-header">
                        <span class="converted-name">‚úÖ ${item.name}</span>
                        <span class="converted-size">${(item.size / 1024 / 1024).toFixed(2)} MB</span>
                    </div>
                    <div class="converted-controls">
                        <audio controls src="${item.url}" style="width:100%; margin-bottom:10px;"></audio>
                        <button class="btn btn-primary btn-small" onclick="downloadFile('${item.id}')">üì• Download</button>
                        <button class="btn btn-danger btn-small" onclick="deleteConvertedFile('${item.id}')">üóëÔ∏è Excluir</button>
                    </div>
                </div>
            `).join('');
        }

        function renderFormatOptions(type = 'audio') {
            const formats = supportedFormats[type];
            elements.formatGrid.innerHTML = formats.map(format => `
                <div class="format-option" data-format="${format}">.${format}</div>
            `).join('');
            
            // Selecionar primeiro formato por padr√£o
            if (formats.length > 0) {
                elements.formatGrid.querySelector('.format-option').classList.add('selected');
            }
        }

        function updateUI() {
            elements.editingGroup.style.display = conversionMode === 'edit-audio' ? 'block' : 'none';
            
            const formatType = conversionMode === 'extract-audio' || conversionMode === 'convert-format' || conversionMode === 'edit-audio' ? 'audio' : 'video';
            renderFormatOptions(formatType);
        }

        // Fun√ß√µes de a√ß√£o
        function removeFile(index) {
            selectedFiles.splice(index, 1);
            renderFileList();
        }

        function downloadFile(id) {
            const item = convertedFiles.find(i => i.id === id);
            if (item) {
                const link = document.createElement('a');
                link.href = item.url;
                link.download = item.name;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                log(`Download de ${item.name} iniciado.`, 'info');
            }
        }

        function deleteConvertedFile(id) {
            convertedFiles = convertedFiles.filter(item => {
                if (item.id === id) {
                    URL.revokeObjectURL(item.url);
                    return false;
                }
                return true;
            });
            renderConvertedFiles();
            log(`Arquivo exclu√≠do.`, 'info');
        }

        // Event Listeners
        function initializeEventListeners() {
            // Sele√ß√£o de arquivos
            elements.dropArea.addEventListener('click', () => elements.fileInput.click());
            
            elements.fileInput.addEventListener('change', (e) => {
                for (const file of e.target.files) {
                    const info = validateFile(file);
                    if (info.valid) {
                        selectedFiles.push(file);
                    } else {
                        log(`Arquivo ${file.name} n√£o suportado.`, 'warning');
                    }
                }
                renderFileList();
            });

            // Drag and Drop
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                elements.dropArea.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                elements.dropArea.addEventListener(eventName, () => {
                    elements.dropArea.classList.add('highlight');
                });
            });

            ['dragleave', 'drop'].forEach(eventName => {
                elements.dropArea.addEventListener(eventName, () => {
                    elements.dropArea.classList.remove('highlight');
                });
            });

            elements.dropArea.addEventListener('drop', (e) => {
                const files = e.dataTransfer.files;
                for (const file of files) {
                    const info = validateFile(file);
                    if (info.valid) {
                        selectedFiles.push(file);
                    } else {
                        log(`Arquivo ${file.name} n√£o suportado.`, 'warning');
                    }
                }
                renderFileList();
            });

            // Sele√ß√£o do modo
            document.querySelectorAll('.method-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    document.querySelector('.method-option.selected')?.classList.remove('selected');
                    e.currentTarget.classList.add('selected');
                    conversionMode = e.currentTarget.dataset.mode;
                    elements.currentMode.textContent = e.currentTarget.querySelector('h4').textContent.trim();
                    updateUI();
                });
            });

            // Sele√ß√£o de formato
            elements.formatGrid.addEventListener('click', (e) => {
                if (e.target.classList.contains('format-option')) {
                    elements.formatGrid.querySelector('.format-option.selected')?.classList.remove('selected');
                    e.target.classList.add('selected');
                }
            });

            // Controles
            elements.processBtn.addEventListener('click', processFiles);
            
            elements.clearBtn.addEventListener('click', () => {
                selectedFiles = [];
                convertedFiles.forEach(item => URL.revokeObjectURL(item.url));
                convertedFiles = [];
                renderFileList();
                renderConvertedFiles();
                setProgress(0, 'Aguardando...');
                log('Arquivos e resultados limpos.', 'info');
            });

            // Volume slider
            elements.volumeSlider.addEventListener('input', () => {
                elements.volumeValue.textContent = `${elements.volumeSlider.value}%`;
            });
        }

        // Inicializa√ß√£o
        function initialize() {
            log('Aplica√ß√£o iniciada. Selecione arquivos para processar.', 'info');
            checkBrowserCompatibility();
            initializeEventListeners();
            updateUI();
        }

        // Tornar fun√ß√µes globais para os bot√µes inline
        window.removeFile = removeFile;
        window.downloadFile = downloadFile;
        window.deleteConvertedFile = deleteConvertedFile;

        // Iniciar quando DOM estiver pronto
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }
    </script>
</body>
</html>
