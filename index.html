<!doctype html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Extrator e Conversor de √Åudio</title>
    <style>
        :root {
            --primary: #007bff;
            --primary-dark: #0056b3;
            --success: #28a745;
            --success-dark: #1e7e34;
            --warning: #ffc107;
            --warning-dark: #d39e00;
            --danger: #dc3545;
            --danger-dark: #c82333;
            --info: #17a2b8;
            --info-dark: #117a8b;
            --bg-light: #f8f9fa;
            --bg-dark: #343a40;
            --text-dark: #212529;
            --text-light: #f8f9fa;
            --border-color: #dee2e6;
            --card-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.05);
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-light);
            color: var(--text-dark);
            margin: 0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        .container {
            width: 100%;
            max-width: 1000px;
            background: #fff;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            padding: 30px;
            border: 1px solid var(--border-color);
        }

        h1 {
            font-size: 2rem;
            margin: 0 0 8px;
            font-weight: 700;
            color: var(--text-dark);
        }

        p.lead {
            color: #6c757d;
            margin: 0 0 20px;
            font-size: 1.1rem;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 0.95rem;
        }

        .alert-warning {
            background-color: #fff3cd;
            border-left: 4px solid var(--warning);
            color: #856404;
        }

        .alert-info {
            background-color: #d1ecf1;
            border-left: 4px solid var(--info);
            color: #0c5460;
        }

        .row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        @media (max-width: 768px) {
            .row {
                flex-direction: column;
            }
        }
        
        .col {
            flex: 1;
            min-width: 280px;
        }

        label {
            display: block;
            font-size: 0.9rem;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
        }

        .drop-area {
            border: 2px dashed var(--border-color);
            padding: 40px 20px;
            text-align: center;
            font-size: 1rem;
            color: #6c757d;
            margin-bottom: 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }

        .drop-area:hover, .drop-area.highlight {
            border-color: var(--primary);
            background-color: #e9f5ff;
            color: var(--primary-dark);
        }
        
        input[type=file] {
            display: none;
        }

        .form-control {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 0.9rem;
            background-color: #fff;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }
        
        .form-control:focus {
            outline: none;
            border-color: var(--primary);
        }

        .btn {
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            border: none;
            transition: all 0.2s ease-in-out;
        }

        .btn-primary {
            background-color: var(--primary);
            color: #fff;
        }
        .btn-primary:hover { background-color: var(--primary-dark); }
        
        .btn-secondary {
            background: transparent;
            color: var(--primary);
            border: 1px solid var(--primary);
        }
        .btn-secondary:hover { background-color: var(--primary-dark); color: #fff; }

        .btn-success {
            background-color: var(--success);
            color: #fff;
        }
        .btn-success:hover { background-color: var(--success-dark); }

        .btn-danger {
            background-color: var(--danger);
            color: #fff;
        }
        .btn-danger:hover { background-color: var(--danger-dark); }
        
        .btn-disabled, .btn:disabled {
            background-color: #adb5bd;
            cursor: not-allowed;
            color: #fff;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .log {
            height: 150px;
            overflow: auto;
            margin-top: 15px;
            background: #212529;
            color: #d1fae5;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .log .error { color: #dc3545; }
        .log .success { color: #28a745; }
        .log .warning { color: #ffc107; }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: var(--border-color);
            border-radius: 5px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--success);
            transition: width 0.3s ease-in-out;
        }
        
        .file-list {
            margin-top: 20px;
        }

        .file-item {
            padding: 15px;
            border-radius: 8px;
            background: #fff;
            margin-bottom: 12px;
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .file-meta {
            font-size: 0.9rem;
            color: #495057;
        }

        .converted-files {
            margin-top: 30px;
        }

        .converted-item {
            padding: 15px;
            background-color: #e2f9e4;
            border: 1px solid #c8e6c9;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .converted-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .converted-name {
            font-weight: 600;
            color: var(--success-dark);
        }

        .converted-size {
            font-size: 0.8rem;
            color: var(--success-dark);
        }

        .converted-controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .method-selector {
            background-color: #e9f5ff;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid var(--primary);
        }

        .method-option {
            margin: 15px 0;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }

        .method-option.selected {
            border-color: var(--primary);
            background-color: #fff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .method-option h4 {
            margin: 0 0 5px;
            color: var(--primary-dark);
            font-weight: 600;
        }

        .method-option p {
            margin: 0;
            font-size: 0.85rem;
            color: #6c757d;
        }

        .tab-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
        }

        .tab-btn {
            background-color: #e9ecef;
            border: 1px solid #dee2e6;
            padding: 10px 15px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px 8px 0 0;
            transition: all 0.2s;
        }
        .tab-btn.active {
            background-color: #fff;
            border-bottom-color: #fff;
        }
        .tab-content {
            border: 1px solid #dee2e6;
            padding: 20px;
            border-radius: 0 8px 8px 8px;
        }

        footer {
            margin-top: 25px;
            font-size: 0.8rem;
            color: #6c757d;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Extrator e Conversor de √Åudio</h1>
        <p class="lead">Extraia √°udio de v√≠deos ou adicione um √°udio a uma imagem.</p>

        <div class="alert alert-warning">
            <strong>‚ö†Ô∏è Limita√ß√£o:</strong> Seu navegador n√£o suporta SharedArrayBuffer. Por isso, a extra√ß√£o/combina√ß√£o de √°udio √© feita usando APIs nativas, e o √°udio de sa√≠da ser√° no formato **WAV** (para extra√ß√£o) ou **WebM** (para cria√ß√£o de v√≠deo).
        </div>

        <div class="alert alert-info">
            <strong>üí° Dica:</strong> Os arquivos convertidos s√£o salvos neste navegador. Eles n√£o ser√£o perdidos se voc√™ recarregar a p√°gina!
        </div>

        <div class="row">
            <div class="col">
                <label>üìπ Selecionar v√≠deo, √°udio ou foto</label>
                <div class="drop-area" id="dropArea">
                    Arraste e solte arquivos aqui, ou clique para selecionar.
                </div>
                <input id="videoInput" type="file" accept="video/*,audio/*,image/*" multiple />

                <div class="method-selector">
                    <h3>üîß Modo de Convers√£o:</h3>
                    <div class="method-option selected" data-mode="extract">
                        <h4>üóÇÔ∏è Extrair √Åudio</h4>
                        <p>Extrai o √°udio de arquivos de v√≠deo ou √°udio. Perfeito para converter.</p>
                    </div>
                    
                    <div class="method-option" data-mode="add-audio">
                        <h4>üîó Adicionar √Åudio</h4>
                        <p>Cria um v√≠deo a partir de uma foto e um √°udio. Apenas para arquivos de imagem.</p>
                    </div>
                </div>

                <div id="addAudioControls" style="display:none;">
                    <h3>üéôÔ∏è Op√ß√µes de √Åudio:</h3>
                    <div class="tab-controls">
                        <button class="tab-btn active" data-tab="text-to-speech">Texto para Voz</button>
                        <button class="tab-btn" data-tab="record-audio">Gravar √Åudio</button>
                        <button class="tab-btn" data-tab="upload-audio">Enviar √Åudio</button>
                    </div>
                    <div class="tab-content" id="tts-content">
                        <h4>üìù Digite o texto:</h4>
                        <textarea id="ttsText" class="form-control" rows="3" placeholder="Digite o texto que deseja transformar em √°udio..."></textarea>
                        <div style="margin-top: 10px;">
                            <label>üó£Ô∏è Voz e Tom:</label>
                            <select id="ttsVoice" class="form-control" style="margin-bottom: 10px;"></select>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <label style="margin: 0; white-space: nowrap;">Pitch: <span id="pitchValue">1.0</span></label>
                                <input type="range" min="0.5" max="2" value="1" step="0.1" id="ttsPitch" style="flex-grow: 1;">
                            </div>
                        </div>
                        <button id="ttsGenerateBtn" class="btn btn-primary" style="margin-top: 20px;">üîä Gerar √Åudio</button>
                    </div>
                    <div class="tab-content" id="record-content" style="display:none;">
                        <h4>üé§ Gravar seu √°udio:</h4>
                        <p style="font-size: 0.9em; color: #6c757d;">Permita o acesso ao seu microfone para come√ßar a gravar.</p>
                        <button id="recordStartBtn" class="btn btn-primary">üî¥ Gravar</button>
                        <button id="recordStopBtn" class="btn btn-danger" style="display:none;">‚èπÔ∏è Parar</button>
                    </div>
                    <div class="tab-content" id="upload-content" style="display:none;">
                        <h4>üìÇ Enviar um arquivo de √°udio:</h4>
                        <p style="font-size: 0.9em; color: #6c757d;">Selecione um arquivo de √°udio do seu computador.</p>
                        <input id="audioInput" type="file" accept="audio/*" />
                        <label for="audioInput" class="btn btn-secondary">Escolher √Åudio</label>
                    </div>
                    <div style="margin-top: 20px;">
                        <audio id="audioPreview" controls style="width: 100%; display: none;"></audio>
                    </div>
                </div>

                <div class="controls">
                    <button id="processBtn" class="btn btn-primary">Processar Arquivo</button>
                    <button id="clearBtn" class="btn btn-danger">üóëÔ∏è Limpar Sele√ß√£o</button>
                    <button id="clearDBBtn" class="btn btn-danger">üóëÔ∏è Limpar Armazenamento</button>
                </div>

                <div class="file-list" id="fileList"></div>
            </div>

            <div class="col">
                <label>üìä Status</label>
                <div class="log" id="log"></div>

                <div style="margin-top:20px">
                    <label>‚öôÔ∏è Progresso</label>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width:0%"></div>
                    </div>
                    <div id="progressText" style="font-size:0.85rem;color:#6c757d">Aguardando...</div>
                </div>
            </div>
        </div>

        <div class="converted-files" id="convertedFiles" style="display:none">
            <h3>üéâ Arquivos Processados</h3>
            <div id="convertedList"></div>
        </div>

        <canvas id="canvas" width="640" height="480" style="display:none;"></canvas>

        <footer>
            <strong>üîß Modo:</strong> <span id="currentMode">Extrair √Åudio</span><br>
            <strong>üî® M√©todo de Extra√ß√£o:</strong> <span id="currentMethod">Web Audio API</span>
        </footer>
    </div>

    <script>
        let selectedFiles = [];
        let convertedAudios = [];
        let isProcessing = false;
        let conversionMode = 'extract';
        let extractionMethod = 'web-audio';
        let db;
        let audioBlobToAttach = null;
        let mediaRecorder;
        let recordedChunks = [];
        let voices = [];
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        const DB_NAME = 'audio-converter-db';
        const STORE_NAME = 'converted-audios';

        const elements = {
            videoInput: document.getElementById('videoInput'),
            fileList: document.getElementById('fileList'),
            processBtn: document.getElementById('processBtn'),
            clearBtn: document.getElementById('clearBtn'),
            clearDBBtn: document.getElementById('clearDBBtn'),
            log: document.getElementById('log'),
            progressFill: document.getElementById('progressFill'),
            progressText: document.getElementById('progressText'),
            convertedFiles: document.getElementById('convertedFiles'),
            convertedList: document.getElementById('convertedList'),
            currentMode: document.getElementById('currentMode'),
            currentMethod: document.getElementById('currentMethod'),
            dropArea: document.getElementById('dropArea'),
            addAudioControls: document.getElementById('addAudioControls'),
            ttsText: document.getElementById('ttsText'),
            ttsVoice: document.getElementById('ttsVoice'),
            ttsPitch: document.getElementById('ttsPitch'),
            ttsPitchValue: document.getElementById('pitchValue'),
            ttsGenerateBtn: document.getElementById('ttsGenerateBtn'),
            recordStartBtn: document.getElementById('recordStartBtn'),
            recordStopBtn: document.getElementById('recordStopBtn'),
            audioInput: document.getElementById('audioInput'),
            audioPreview: document.getElementById('audioPreview'),
            tabBtns: document.querySelectorAll('.tab-btn'),
            tabContents: document.querySelectorAll('.tab-content'),
        };

        function log(msg, type = 'info') {
            const time = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.className = type;
            div.textContent = `[${time}] ${msg}`;
            elements.log.appendChild(div);
            elements.log.scrollTop = elements.log.scrollHeight;
        }

        function setProgress(percent, text) {
            elements.progressFill.style.width = `${percent}%`;
            elements.progressText.textContent = text;
        }

        // IndexedDB Functions
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve();
                };
                request.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        }

        async function saveAudioToDB(audioData) {
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            const id = `audio-${Date.now()}`;
            const dataToSave = {
                id: id,
                name: audioData.name,
                size: audioData.size,
                blob: audioData.blob,
                type: audioData.type
            };
            await store.put(dataToSave);
            return dataToSave;
        }

        async function getAudiosFromDB() {
            const tx = db.transaction(STORE_NAME, 'readonly');
            const store = tx.objectStore(STORE_NAME);
            const request = store.getAll();
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function deleteAudioFromDB(id) {
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            await store.delete(id);
        }

        async function clearDB() {
            const tx = db.transaction(STORE_NAME, 'readwrite');
            const store = tx.objectStore(STORE_NAME);
            await store.clear();
        }

        // UI & Logic
        elements.tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                elements.tabBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                elements.tabContents.forEach(c => c.style.display = 'none');
                document.getElementById(btn.dataset.tab + '-content').style.display = 'block';
            });
        });

        elements.ttsPitch.addEventListener('input', () => {
            elements.ttsPitchValue.textContent = elements.ttsPitch.value;
        });

        window.speechSynthesis.onvoiceschanged = () => {
            voices = window.speechSynthesis.getVoices().filter(v => v.lang.startsWith('pt-BR'));
            elements.ttsVoice.innerHTML = '';
            voices.forEach((voice, i) => {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `${voice.name} (${voice.lang}) - ${voice.default ? 'Padr√£o' : ''}`;
                elements.ttsVoice.appendChild(option);
            });
        };

        elements.ttsGenerateBtn.addEventListener('click', () => {
            const text = elements.ttsText.value;
            if (!text) {
                alert('Por favor, digite um texto.');
                return;
            }

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.voice = voices[elements.ttsVoice.value];
            utterance.pitch = parseFloat(elements.ttsPitch.value);
            
            const destination = audioContext.createMediaStreamDestination();
            const recorder = new MediaRecorder(destination.stream);
            let chunks = [];
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                audioBlobToAttach = new Blob(chunks, { type: 'audio/webm' });
                elements.audioPreview.src = URL.createObjectURL(audioBlobToAttach);
                elements.audioPreview.style.display = 'block';
                log('‚úÖ √Åudio gerado a partir do texto.');
            };

            speechSynthesis.speak(utterance);
            
            utterance.onstart = () => recorder.start();
            utterance.onend = () => recorder.stop();
        });

        elements.recordStartBtn.addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                recordedChunks = [];
                mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);
                mediaRecorder.onstop = () => {
                    audioBlobToAttach = new Blob(recordedChunks, { type: 'audio/webm' });
                    elements.audioPreview.src = URL.createObjectURL(audioBlobToAttach);
                    elements.audioPreview.style.display = 'block';
                    log('‚úÖ Grava√ß√£o conclu√≠da.');
                    elements.recordStartBtn.style.display = 'block';
                    elements.recordStopBtn.style.display = 'none';
                };
                mediaRecorder.start();
                elements.recordStartBtn.style.display = 'none';
                elements.recordStopBtn.style.display = 'block';
                log('üî¥ Grava√ß√£o iniciada...');
            } catch (err) {
                log(`‚ùå Erro ao acessar microfone: ${err.message}`, 'error');
            }
        });

        elements.recordStopBtn.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
        });

        elements.audioInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                const file = e.target.files[0];
                audioBlobToAttach = file;
                elements.audioPreview.src = URL.createObjectURL(file);
                elements.audioPreview.style.display = 'block';
                log(`‚úÖ Arquivo de √°udio "${file.name}" carregado.`);
            }
        });

        // Event Listeners for main buttons
        document.querySelectorAll('.method-option').forEach(option => {
            option.addEventListener('click', () => {
                const parent = option.parentElement;
                parent.querySelector('.method-option.selected')?.classList.remove('selected');
                option.classList.add('selected');
                conversionMode = option.dataset.mode;
                elements.currentMode.textContent = option.querySelector('h4').textContent;
                log(`Modo de convers√£o alterado: ${option.querySelector('h4').textContent}`);
                
                if (conversionMode === 'add-audio') {
                    elements.addAudioControls.style.display = 'block';
                } else {
                    elements.addAudioControls.style.display = 'none';
                    audioBlobToAttach = null;
                    elements.audioPreview.style.display = 'none';
                }
            });
        });

        elements.dropArea.addEventListener('click', () => elements.videoInput.click());
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            elements.dropArea.addEventListener(eventName, e => {
                e.preventDefault();
                e.stopPropagation();
            }, false);
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            elements.dropArea.addEventListener(eventName, () => elements.dropArea.classList.add('highlight'), false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            elements.dropArea.addEventListener(eventName, () => elements.dropArea.classList.remove('highlight'), false);
        });
        elements.dropArea.addEventListener('drop', e => {
            selectedFiles = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('video/') || f.type.startsWith('audio/') || f.type.startsWith('image/'));
            renderFileList();
            log(`üìÅ ${selectedFiles.length} arquivo(s) selecionado(s) via arrastar e soltar`);
        }, false);
        elements.videoInput.addEventListener('change', e => {
            selectedFiles = Array.from(e.target.files).filter(f => f.type.startsWith('video/') || f.type.startsWith('audio/') || f.type.startsWith('image/'));
            renderFileList();
            log(`üìÅ ${selectedFiles.length} arquivo(s) selecionado(s)`);
        });
        function renderFileList() {
            if (selectedFiles.length === 0) {
                elements.fileList.innerHTML = '<div style="color:#6c757d;font-style:italic;padding:15px;text-align:center;">Nenhum arquivo</div>';
                return;
            }
            elements.fileList.innerHTML = selectedFiles.map((file, idx) => `
                <div class="file-item">
                    <div class="file-meta">
                        <strong>${file.name}</strong><br>
                        <small>üìè ${(file.size/1024/1024).toFixed(2)} MB ‚Ä¢ üé¨ ${file.type}</small>
                    </div>
                </div>
            `).join('');
        }
        function renderConvertedFiles() {
            if (convertedAudios.length === 0) {
                elements.convertedFiles.style.display = 'none';
                return;
            }
            elements.convertedFiles.style.display = 'block';
            elements.convertedList.innerHTML = convertedAudios.map((audio, idx) => `
                <div class="converted-item">
                    <div class="converted-header">
                        <div class="converted-name">üéµ ${audio.name}</div>
                        <div class="converted-size">${(audio.size/1024/1024).toFixed(2)} MB</div>
                    </div>
                    ${audio.type.startsWith('video/') ? `<video controls style="width: 100%;"></video>` : `<audio controls style="width: 100%;"></audio>`}
                    <div class="converted-controls">
                        <button onclick="downloadAudio(${idx})" class="btn btn-success">üíæ Baixar</button>
                        <button onclick="removeAudio(${idx})" class="btn btn-danger">üóëÔ∏è Remover</button>
                    </div>
                </div>
            `).join('');
            document.querySelectorAll('.converted-item').forEach((item, idx) => {
                const player = item.querySelector('video') || item.querySelector('audio');
                player.src = convertedAudios[idx].url;
            });
        }
        window.downloadAudio = (idx) => {
            const audio = convertedAudios[idx];
            const a = document.createElement('a');
            a.href = audio.url;
            a.download = audio.name;
            a.click();
            log(`üíæ Download: ${audio.name}`);
        };
        window.removeAudio = async (idx) => {
            const audio = convertedAudios[idx];
            URL.revokeObjectURL(audio.url);
            await deleteAudioFromDB(audio.id);
            convertedAudios.splice(idx, 1);
            renderConvertedFiles();
            log(`üóëÔ∏è Removido: ${audio.name}`);
        };

        // Core processing logic
        async function processFile() {
            if (isProcessing) return;
            if (selectedFiles.length === 0) {
                alert('Selecione um arquivo de entrada!');
                return;
            }
            const file = selectedFiles[0];

            isProcessing = true;
            elements.processBtn.disabled = true;
            elements.processBtn.textContent = 'Processando...';
            convertedAudios = [];
            
            if (conversionMode === 'extract') {
                if (!file.type.startsWith('video/') && !file.type.startsWith('audio/')) {
                    alert('Para extrair √°udio, por favor selecione um arquivo de v√≠deo ou √°udio.');
                    isProcessing = false;
                    elements.processBtn.disabled = false;
                    elements.processBtn.textContent = 'Processar Arquivo';
                    return;
                }
                await extractAudioFromFile(file);
            } else if (conversionMode === 'add-audio') {
                if (!file.type.startsWith('image/')) {
                    alert('Para adicionar √°udio, por favor selecione um arquivo de imagem.');
                    isProcessing = false;
                    elements.processBtn.disabled = false;
                    elements.processBtn.textContent = 'Processar Arquivo';
                    return;
                }
                if (!audioBlobToAttach) {
                    alert('Por favor, crie ou selecione um √°udio para adicionar.');
                    isProcessing = false;
                    elements.processBtn.disabled = false;
                    elements.processBtn.textContent = 'Processar Arquivo';
                    return;
                }
                await addAudioToImage(file, audioBlobToAttach);
            }

            isProcessing = false;
            elements.processBtn.disabled = false;
            elements.processBtn.textContent = 'Processar Arquivo';
            setProgress(100, 'Conclu√≠do!');
            log('üéâ Processamento finalizado!', 'success');
            renderConvertedFiles();
        }

        async function extractAudioFromFile(file) {
            setProgress(0, `Extraindo √°udio de ${file.name}...`);
            log(`üîÑ Extraindo √°udio...`);
            try {
                const audioBuffer = await audioContext.decodeAudioData(await file.arrayBuffer());
                const wav = audioBufferToWav(audioBuffer);
                const blob = new Blob([wav], { type: 'audio/wav' });
                const savedAudio = await saveAudioToDB({
                    name: file.name.replace(/\.[^/.]+$/, '') + '.wav',
                    size: blob.size,
                    blob: blob,
                    type: 'audio/wav'
                });
                convertedAudios.push({
                    ...savedAudio,
                    url: URL.createObjectURL(savedAudio.blob)
                });
                log(`‚úÖ √Åudio extra√≠do e salvo: ${savedAudio.name}`, 'success');
            } catch (err) {
                log(`‚ùå Erro ao extrair √°udio: ${err.message}`, 'error');
            }
        }

        async function addAudioToImage(imageFile, audioBlob) {
            setProgress(0, `Combinando imagem e √°udio...`);
            log(`üîÑ Combinando imagem e √°udio...`);
            const videoMimeType = 'video/webm; codecs="opus,vp9"';
            
            try {
                const image = new Image();
                image.src = URL.createObjectURL(imageFile);
                await new Promise(resolve => image.onload = resolve);
                
                canvas.width = image.width;
                canvas.height = image.height;
                ctx.drawImage(image, 0, 0);

                const audio = new Audio();
                audio.src = URL.createObjectURL(audioBlob);
                await new Promise(resolve => {
                    audio.oncanplaythrough = resolve;
                    audio.load();
                });
                
                const audioSource = audioContext.createMediaElementSource(audio);
                const audioDestination = audioContext.createMediaStreamDestination();
                audioSource.connect(audioDestination);

                const canvasStream = canvas.captureStream();
                canvasStream.addTrack(audioDestination.stream.getAudioTracks()[0]);

                const recorder = new MediaRecorder(canvasStream, { mimeType: videoMimeType });
                let chunks = [];
                recorder.ondataavailable = e => chunks.push(e.data);
                recorder.onstop = async () => {
                    const videoBlob = new Blob(chunks, { type: videoMimeType });
                    const savedVideo = await saveAudioToDB({
                        name: `video_${imageFile.name.replace(/\.[^/.]+$/, '')}_${Date.now()}.webm`,
                        size: videoBlob.size,
                        blob: videoBlob,
                        type: 'video/webm'
                    });
                    convertedAudios.push({
                        ...savedVideo,
                        url: URL.createObjectURL(savedVideo.blob)
                    });
                    log(`‚úÖ V√≠deo criado e salvo: ${savedVideo.name}`, 'success');

                    elements.processBtn.disabled = false;
                    elements.processBtn.textContent = 'Processar Arquivo';
                    setProgress(100, 'Conclu√≠do!');
                    renderConvertedFiles();
                };

                recorder.start();
                audio.play();

                audio.onended = () => {
                    recorder.stop();
                    audio.pause();
                    canvasStream.getTracks().forEach(track => track.stop());
                };
            } catch (err) {
                log(`‚ùå Erro ao combinar arquivos: ${err.message}`, 'error');
                isProcessing = false;
                elements.processBtn.disabled = false;
                elements.processBtn.textContent = 'Processar Arquivo';
            }
        }

        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const length = buffer.length;
            const sampleRate = buffer.sampleRate;
            const arrayBuffer = new ArrayBuffer(44 + length * numChannels * 2);
            const view = new DataView(arrayBuffer);
            
            const writeString = (offset, str) => {
                for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
            };
            
            writeString(0, 'RIFF'); view.setUint32(4, 36 + length * numChannels * 2, true);
            writeString(8, 'WAVE'); writeString(12, 'fmt '); view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * numChannels * 2, true);
            view.setUint16(32, numChannels * 2, true); view.setUint16(34, 16, true);
            writeString(36, 'data'); view.setUint32(40, length * numChannels * 2, true);
            
            let offset = 44;
            for (let i = 0; i < length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample * 0x7FFF, true);
                    offset += 2;
                }
            }
            return arrayBuffer;
        }

        elements.processBtn.addEventListener('click', processFile);
        elements.clearBtn.addEventListener('click', () => {
            selectedFiles = [];
            elements.videoInput.value = '';
            renderFileList();
            elements.log.innerHTML = '';
            setProgress(0, 'Limpo!');
            log('üßπ Arquivos de entrada e log limpos.');
        });
        elements.clearDBBtn.addEventListener('click', async () => {
            const confirmClear = confirm('Tem certeza de que deseja remover todos os arquivos do armazenamento do navegador?');
            if (confirmClear) {
                convertedAudios.forEach(audio => URL.revokeObjectURL(audio.url));
                await clearDB();
                convertedAudios = [];
                renderConvertedFiles();
                log('üóëÔ∏è Todo o armazenamento local foi limpo!', 'success');
            }
        });

        (async () => {
            log('üöÄ Extrator de √°udio carregado!');
            log('üí° Este sistema n√£o usa FFmpeg, mas extrai o √°udio com APIs do navegador no formato WAV (para extra√ß√£o) ou WebM (para cria√ß√£o de v√≠deo).');
            await openDB();
            const audiosFromDB = await getAudiosFromDB();
            convertedAudios = audiosFromDB.map(audio => ({
                ...audio,
                url: URL.createObjectURL(audio.blob)
            }));
            renderConvertedFiles();
            if (convertedAudios.length > 0) {
                log(`‚úÖ ${convertedAudios.length} arquivo(s) encontrado(s) e carregado(s)!`, 'success');
            } else {
                log('Nenhum arquivo encontrado.');
            }
            if (window.speechSynthesis) {
                window.speechSynthesis.getVoices();
            } else {
                log('Seu navegador n√£o suporta a API de Convers√£o de Texto em Voz.', 'warning');
            }
        })();
    </script>
</body>
</html>
